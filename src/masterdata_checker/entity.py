"""
Created on Wed Dec 27 15:02:19 2023

@author: cmadaria
"""

import re

import openpyxl

from masterdata_checker.content import index_to_excel_column

# =============================================================================
# file_path = "C:/Users/cmadaria/Documents/Projects/Type checker/object_type_CHEMICAL_v2_S.3_cmadaria.xlsx"
# =============================================================================


def search_entity(o, e_type, e_code):
    if e_type == 'EXPERIMENT_TYPE':
        return o.get_collection_type(e_code)

    elif e_type == 'SAMPLE_TYPE':
        return o.get_object_type(e_code)

    elif e_type == 'DATASET_TYPE':
        return o.get_dataset_type(e_code)


def get_entity_list(o, entity_type):
    if entity_type == 'EXPERIMENT_TYPE':
        return o.get_collection_types()

    elif entity_type == 'SAMPLE_TYPE':
        return o.get_object_types()

    elif entity_type == 'DATASET_TYPE':
        return o.get_dataset_types()


def compare_objects(obj1, obj2):
    # Check if both are None or both are empty strings
    if (obj1 is None and obj2 == '') or (obj1 == '' and obj2 is None):
        return True
    elif (obj1 == 'False' and obj2 == 'FALSE') or (obj1 == 'FALSE' and obj2 == 'False'):
        return True
    elif (obj1 == 'True' and obj2 == 'TRUE') or (obj1 == 'TRUE' and obj2 == 'True'):
        return True
    else:
        return obj1 == obj2


def get_df_value(df, prop, attr):
    column_name = 'propertyType'

    # Check if 'propertyType' column exists in the DataFrame
    if column_name not in df.columns:
        return None  # or handle this case appropriately

    value_to_find = prop

    # Create a boolean mask for rows where the condition is met
    mask = df[column_name] == value_to_find

    # Use the boolean mask to filter the DataFrame
    filtered_df = df[mask]

    if not filtered_df.empty:
        return filtered_df[attr].iloc[0] if attr in filtered_df.columns else None
    else:
        return None


def check_entity_same_code(file_path, o, openbis_entity):
    errors = []
    description = ''
    auto_code = ''
    val_script = ''
    prefix_code = ''

    workbook = openpyxl.load_workbook(file_path)
    sheet = workbook.active
    entity_type = sheet['A1'].value
    second_row_values = [cell.value for cell in sheet[2]]

    for term in second_row_values:
        term_index = second_row_values.index(term)
        if term == 'Code':
            entity_code = sheet.cell(row=3, column=term_index + 1).value
        elif term == 'Description':
            description = sheet.cell(row=3, column=term_index + 1).value
        elif term == 'Auto generate codes':
            auto_code = sheet.cell(row=3, column=term_index + 1).value
        elif term == 'Validation script':
            val_script = sheet.cell(row=3, column=term_index + 1).value
        elif term == 'Generated code prefix':
            prefix_code = sheet.cell(row=3, column=term_index + 1).value

        # format values to match
        if auto_code is True:
            auto_code = 'TRUE'
        elif auto_code is False:
            auto_code = 'FALSE'
        if val_script is None:
            val_script = ''

    openbis_description = openbis_entity.description
    openbis_auto_code = openbis_entity.autoGeneratedCode
    openbis_val_script = openbis_entity.validationPlugin
    openbis_prefix_code = openbis_entity.generatedCodePrefix

    # cast values to STRING t match Excel data
    if openbis_auto_code is True:
        openbis_auto_code = 'TRUE'
    elif openbis_auto_code is False:
        openbis_auto_code = 'FALSE'
    if openbis_val_script is None:
        openbis_val_script = ''

    # check description
    if description != openbis_description:
        errors.append(
            f"The Description of ('{entity_type}') '{entity_code}' has been changed compared to the previous version."
        )
        description_pattern = re.compile(r'.*//.*')
        if not description_pattern.match(description):
            errors.append(
                "Error: The Description of ('{entity_type}') '{entity_code}' should follow the schema: English Description + '//' + German Description."
            )

    # check auto-generated codes
    if auto_code != openbis_auto_code:
        errors.append(
            f"The value of “Auto generate codes” of ('{entity_type}') '{entity_code}' has been changed from '{openbis_auto_code}' to '{auto_code}'."
        )

    # check validation scripts
    if val_script == '' and openbis_val_script != '':
        errors.append(
            f"The validation script '{openbis_val_script}' has been deleted from ('{entity_type}') '{entity_code}'."
        )
    elif val_script != '' and openbis_val_script == '':
        errors.append(
            f"A validation script '{val_script}' has been added to ('{entity_type}') '{entity_code}'."
        )
    elif val_script != openbis_val_script:
        errors.append(
            f"The validation script of ('{entity_type}') '{entity_code}' has been changed from '{openbis_val_script}' to '{val_script}'."
        )

    # check generated code prefix
    if prefix_code != openbis_prefix_code:
        errors.append(
            f"The Code Prefix of ('{entity_type}') '{entity_code}' has been changed from '{openbis_prefix_code}' to '{prefix_code}'."
        )

    # get assigned properties from the excel file
    prop_headers = [cell.value for cell in sheet[4]]
    entity_properties = []
    term_index = prop_headers.index('Code') + 1
    term_letter = index_to_excel_column(term_index)

    for cell in sheet[term_letter][4:]:
        if cell.value is not None:
            entity_properties.append(cell.value)

    # get assigned properties from the openbis instance
    openbis_entity_properties = []
    for prop in openbis_entity.get_property_assignments():
        openbis_entity_properties.append(prop.permId)

    # Remove None values from both lists before sorting
    entity_properties = [prop for prop in entity_properties if prop is not None]
    openbis_entity_properties = [
        prop for prop in openbis_entity_properties if prop is not None
    ]

    # check if the properties lists are the same
    if sorted(entity_properties) != sorted(openbis_entity_properties):
        errors.append(
            f"The set of Property Types assigned to the ('{entity_type}') '{entity_code}' has been changed compared to the previous version."
        )

    # check which properties has been added and removed
    deleted_properties = []
    added_properties = []

    deleted_properties = list(set(openbis_entity_properties) - set(entity_properties))
    added_properties = list(set(entity_properties) - set(openbis_entity_properties))

    for d_prop in deleted_properties:
        errors.append(f"The Property type assignment '{d_prop}' has been removed.")
    for a_prop in added_properties:
        errors.append(f"The Property type assignment '{a_prop}' has been added.")

    # =============================================================================
    #         for prop in openbis_entity.get_property_assignments():
    #             print(prop.attrs.all())
    # NOT WORKING ANYWAY; TO GET ALL THE REQUESTED VALUES
    # =============================================================================

    # save dict with all the properties values from the entity in the instance
    openbis_properties_data = {}
    for prop in openbis_entity.get_property_assignments():
        openbis_properties_data[prop.code] = {
            'label': prop.label,
            'description': prop.description,
            'dataType': prop.dataType,
            'vocabulary': prop.vocabulary if prop.vocabulary is not None else '',
            'metaData': prop.metaData,
        }

    # save dict with all the properties values from the excel metadata file
    prop_headers = [cell.value for cell in sheet[4]]
    properties_data = {}
    term_index = prop_headers.index('Code') + 1
    term_letter = index_to_excel_column(term_index)

    for row in sheet.iter_rows(min_row=5, values_only=True):
        code_value = row[term_index - 1]  # Index is 0-based
        if code_value is not None:
            properties_data[code_value] = {
                'label': row[prop_headers.index('Property label')],
                'description': row[prop_headers.index('Description')],
                'dataType': row[prop_headers.index('Data type')],
                'vocabulary': row[prop_headers.index('Vocabulary code')]
                if row[prop_headers.index('Vocabulary code')] is not None
                else '',
                'metaData': {}
                if row[prop_headers.index('Metadata')] in (None, '')
                else row[prop_headers.index('Metadata')],
                'mandatory': row[prop_headers.index('Mandatory')],
                'section': row[prop_headers.index('Section')],
                'plugin': row[prop_headers.index('Dynamic script')],
            }

    # =============================================================================
    # COMPARE EXCEL PROPERTIES WITH ALL THE INSTANCE PROPERTIES, NOT ASSIGNED ONES
    #     for key in properties_data.keys():
    #         try:
    #             prop_ob = o.get_property_type(key)
    #             if not compare_objects(properties_data[key]['label'],prop_ob.label):
    #                 errors.append(f"The label of Property type {key} has been changed compared to the previous version from {prop_ob.label} to {properties_data[key]['label']}.")
    #             elif not compare_objects(properties_data[key]['description'],prop_ob.description):
    #                 errors.append(f"The description of Property type {key} has been changed compared to the previous version from {prop_ob.description} to {properties_data[key]['description']}.")
    #             elif not compare_objects(properties_data[key]['dataType'],prop_ob.dataType):
    #                 errors.append(f"The data type of Property type {key} has been changed compared to the previous version from {prop_ob.dataType} to {properties_data[key]['dataType']}. This is only permissible for some cases, e.g., 'CONTROLLEDVOCABULARY' to 'VARCHAR'!")
    #             elif not compare_objects(properties_data[key]['vocabulary'],prop_ob.vocabulary):
    #                 errors.append(f"The vocabulary code of Property type {key} has been changed compared to the previous version from {prop_ob.vocabulary} to {properties_data[key]['vocabulary']}. This is not allowed.")
    #             elif not compare_objects(properties_data[key]['metaData'],prop_ob.metaData):
    #                 errors.append(f"The metadata of Property type {key} has been changed compared to the previous version from {prop_ob.metaData} to {properties_data[key]['metaData']}. This is not allowed.")
    #         except ValueError:
    #             continue
    # =============================================================================

    assigned_properties = openbis_entity.get_property_assignments().df
    # properties present in the excel but not in openbis: not assigned
    not_assigned_properties = set(properties_data.keys()) - set(
        openbis_properties_data.keys()
    )

    # compare both dicts with sets of properties to check the differences
    for key in openbis_properties_data.keys() & properties_data.keys():
        for assigned_field in ['mandatory', 'section', 'plugin']:
            excel_assigned = properties_data[key][assigned_field]
            openbis_assigned = get_df_value(assigned_properties, key, assigned_field)
            if not compare_objects(excel_assigned, openbis_assigned):
                if assigned_field == 'mandatory':
                    if (
                        str(openbis_assigned).upper() == 'FALSE'
                        and str(excel_assigned).upper() == 'TRUE'
                    ):
                        errors.append(
                            f"The value of the attribute 'Mandatory' of Property type {key} has been changed compared to the previous version from FALSE to TRUE."
                        )
                    elif (
                        str(openbis_assigned).upper() == 'TRUE'
                        and str(excel_assigned).upper() == 'FALSE'
                    ):
                        errors.append(
                            f"ERROR: The value of the attribute 'Mandatory' of Property type {key} has been changed compared to the previous version from TRUE to FALSE. This is NOT allowed"
                        )
                elif assigned_field == 'section':
                    errors.append(
                        f'The section of Property type {key} has been changed compared to the previous version from {openbis_assigned} to {excel_assigned}.'
                    )
                elif assigned_field == 'plugin':
                    if (openbis_assigned == '' or openbis_assigned is None) and (
                        excel_assigned != '' or excel_assigned is not None
                    ):
                        errors.append(
                            f'WARNING: A dynamic property script ({excel_assigned}) has been added retrospectively to the Property type {key}.'
                        )
                    elif str(openbis_assigned).upper() != str(excel_assigned).upper():
                        errors.append(
                            f'ERROR: The dynamic property script of Property type {key} has been changed or deleted compared to the previous version. This is NOT allowed'
                        )

        for field in ['label', 'description', 'dataType', 'vocabulary', 'metaData']:
            value1 = openbis_properties_data[key][field]
            value2 = properties_data[key][field]
            if not compare_objects(value1, value2):
                if field == 'label':
                    errors.append(
                        f'The label of Property type {key} has been changed compared to the previous version from {value1} to {value2}.'
                    )
                elif field == 'description':
                    errors.append(
                        f'The description of Property type {key} has been changed compared to the previous version from {value1} to {value2}.'
                    )
                elif field == 'dataType':
                    errors.append(
                        f"WARNING: The data type of Property type {key} has been changed compared to the previous version from from {value1} to {value2}. This is only permissible for some cases, e.g., 'CONTROLLEDVOCABULARY' to 'VARCHAR'!"
                    )
                elif field == 'vocabulary':
                    errors.append(
                        f'ERROR: The vocabulary code of Property type {key} has been changed compared to the previous version from from {value1} to {value2}. This is not allowed.'
                    )
                elif field == 'metaData':
                    errors.append(
                        f'ERROR: The metadata of Property type {key} has been changed compared to the previous version from from {value1} to {value2}. This is not allowed.'
                    )

    for key in not_assigned_properties:
        try:
            prop_ob = o.get_property_type(key)
            if not compare_objects(properties_data[key]['label'], prop_ob.label):
                errors.append(
                    f"The label of Property type {key} has been changed compared to the previous version from {prop_ob.label} to {properties_data[key]['label']}."
                )
            elif not compare_objects(
                properties_data[key]['description'], prop_ob.description
            ):
                errors.append(
                    f"The description of Property type {key} has been changed compared to the previous version from {prop_ob.description} to {properties_data[key]['description']}."
                )
            elif not compare_objects(
                properties_data[key]['dataType'], prop_ob.dataType
            ):
                errors.append(
                    f"The data type of Property type {key} has been changed compared to the previous version from {prop_ob.dataType} to {properties_data[key]['dataType']}. This is only permissible for some cases, e.g., 'CONTROLLEDVOCABULARY' to 'VARCHAR'!"
                )
            elif not compare_objects(
                properties_data[key]['vocabulary'], prop_ob.vocabulary
            ):
                errors.append(
                    f"The vocabulary code of Property type {key} has been changed compared to the previous version from {prop_ob.vocabulary} to {properties_data[key]['vocabulary']}. This is not allowed."
                )
            elif not compare_objects(
                properties_data[key]['metaData'], prop_ob.metaData
            ):
                errors.append(
                    f"The metadata of Property type {key} has been changed compared to the previous version from {prop_ob.metaData} to {properties_data[key]['metaData']}. This is not allowed."
                )
        except ValueError:
            continue

    workbook.close()

    return '\n'.join(errors)


def check_entity_diff_code(file_path, o):
    errors = []

    workbook = openpyxl.load_workbook(file_path)
    sheet = workbook.active
    entity_type = sheet['A1'].value

    openbis_entity_types = get_entity_list(o, entity_type)

    openbis_entity_properties = {}

    # get all the properties for each entity type from the instance, and save them in a dictionary
    for etype in openbis_entity_types:
        props_by_type = []
        openbis_entity_properties[etype.code] = []
        if etype.code != 'UNKNOWN':
            for prop in etype.get_property_assignments():
                props_by_type.append(prop.permId)
            openbis_entity_properties[etype.code] = props_by_type

    # get the assigned properties of the entity in the excel
    entity_headers = [cell.value for cell in sheet[2]]
    entity_properties = []
    term_index = entity_headers.index('Code') + 1
    entity_code = sheet.cell(row=3, column=term_index).value
    term_letter = index_to_excel_column(term_index)

    for cell in sheet[term_letter][4:]:
        if cell.value is not None:
            entity_properties.append(cell.value)

    for key, prop_list in openbis_entity_properties.items():
        if set(prop_list) == set(entity_properties):
            errors.append(
                f"The {entity_type} '{entity_code}' is very similar to the existing {entity_type} '{key}'. Please consider whether you need to create a new entity type or whether you can re-use '{key}'"
            )

    return '\n'.join(errors)


def check_prefix_sufix(file_path, o):
    errors = []

    workbook = openpyxl.load_workbook(file_path)
    sheet = workbook.active
    entity_type = sheet['A1'].value

    entity_headers = [cell.value for cell in sheet[2]]
    term_index = entity_headers.index('Code') + 1
    entity_code = sheet.cell(row=3, column=term_index).value

    pattern = re.compile(r'^[A-Za-z0-9_.]+\.[A-Za-z0-9_]+$')

    if pattern.match(entity_code):
        parts = entity_code.rsplit('.', 1)
        prefix = parts[0]

        prop_headers = [cell.value for cell in sheet[4]]
        entity_properties = []
        term_index = prop_headers.index('Code') + 1
        term_letter = index_to_excel_column(term_index)

        for cell in sheet[term_letter][4:]:
            if cell.value is not None:
                entity_properties.append(cell.value)

        # get assigned properties from the openbis instance
        try:
            prefix_entity = search_entity(o, entity_type, prefix)
        except ValueError:
            errors.append(
                f"Entity type '{prefix}' is not present in the system, and cannot be the prefix of a new entity to be registered."
            )
            return '\n'.join(errors)

        prefix_properties = []
        for prop in prefix_entity.get_property_assignments():
            prefix_properties.append(prop.permId)

        # get the properties that are in the PREFIX but not in the SUFIX
        difference = [
            value for value in prefix_properties if value not in entity_properties
        ]

        prefix_properties_data = {}
        for prop in prefix_entity.get_property_assignments():
            prefix_properties_data[prop.code] = {
                'label': prop.label,
                'description': prop.description,
                'dataType': prop.dataType,
                'vocabulary': prop.vocabulary if prop.vocabulary is not None else '',
                'metaData': prop.metaData,
            }

        entity_properties_data = {}
        for row in sheet.iter_rows(min_row=5, values_only=True):
            code_value = row[term_index - 1]  # Index is 0-based
            if code_value is not None:
                entity_properties_data[code_value] = {
                    'label': row[prop_headers.index('Property label')],
                    'description': row[prop_headers.index('Description')],
                    'dataType': row[prop_headers.index('Data type')],
                    'vocabulary': row[prop_headers.index('Vocabulary code')]
                    if row[prop_headers.index('Vocabulary code')] is not None
                    else '',
                    'metaData': {}
                    if row[prop_headers.index('Metadata')] in (None, '')
                    else row[prop_headers.index('Metadata')],
                }

        changes = []
        # compare both dicts with sets of properties to check the differences
        for key in prefix_properties_data.keys() & entity_properties_data.keys():
            for field in ['label', 'description', 'dataType', 'vocabulary', 'metaData']:
                value1 = prefix_properties_data[key][field]
                value2 = entity_properties_data[key][field]
                if value1 != value2:
                    if field == 'label':
                        changes.append(f'Change in label of Property type {key}.')
                    elif field == 'description':
                        changes.append(f'Change in description of Property type {key}.')
                    elif field == 'dataType':
                        changes.append(f'Change in data type of Property type {key}.')
                    elif field == 'vocabulary':
                        changes.append(
                            f'Change in vocabulary code of Property type {key}.'
                        )
                    elif field == 'metaData':
                        changes.append(f'Change in metadata of Property type {key}.')

        if (len(difference) != 0) or (len(changes) != 0):
            errors.append(
                f'As a specification of the entity type {prefix}, the entity type {entity_code} must include all Property types of {prefix} without any changes.'
            )
            errors.append('The missing properties are: ')
            missing = ', '.join(difference)
            errors.append(missing)
            errors.append('\n')
            errors.append('The changed property attributes are: ')
            changed = '\n'.join(changes)
            errors.append(changed)

        check_prefix_prefix(o, prefix, entity_type, errors)

    return '\n'.join(errors)


def check_prefix_prefix(o, prefix, entity_type, errors):
    if '.' in prefix:
        # Split the string by the last dot
        prefix_2, suffix = prefix.rsplit('.', 1)

        prefix_entity = search_entity(o, entity_type, prefix_2)
        suffix_entity = search_entity(o, entity_type, suffix)

        prefix_properties = []
        for prop in prefix_entity.get_property_assignments():
            prefix_properties.append(prop.permId)

        suffix_properties = []
        for prop in suffix_entity.get_property_assignments():
            suffix_properties.append(prop.permId)

        difference = [
            value for value in prefix_properties if value not in suffix_properties
        ]

        prefix_properties_data = {}
        for prop in prefix_entity.get_property_assignments():
            prefix_properties_data[prop.code] = {
                'label': prop.label,
                'description': prop.description,
                'dataType': prop.dataType,
                'vocabulary': prop.vocabulary if prop.vocabulary is not None else '',
                'metaData': prop.metaData,
            }

        suffix_properties_data = {}
        for prop2 in suffix_entity.get_property_assignments():
            suffix_properties_data[prop2.code] = {
                'label': prop2.label,
                'description': prop2.description,
                'dataType': prop2.dataType,
                'vocabulary': prop2.vocabulary if prop2.vocabulary is not None else '',
                'metaData': prop2.metaData,
            }

        changes = []
        # compare both dicts with sets of properties to check the differences
        for key in prefix_properties_data.keys() & suffix_properties_data.keys():
            for field in ['label', 'description', 'dataType', 'vocabulary', 'metaData']:
                value1 = prefix_properties_data[key][field]
                value2 = suffix_properties_data[key][field]
                if value1 != value2:
                    if field == 'label':
                        changes.append(f'Change in label of Property type {key}.')
                    elif field == 'description':
                        changes.append(f'Change in description of Property type {key}.')
                    elif field == 'dataType':
                        changes.append(f'Change in data type of Property type {key}.')
                    elif field == 'vocabulary':
                        changes.append(
                            f'Change in vocabulary code of Property type {key}.'
                        )
                    elif field == 'metaData':
                        changes.append(f'Change in metadata of Property type {key}.')

        if (len(difference) != 0) or (len(changes) != 0):
            errors.append(
                f'As a specification of the entity type {prefix}, the entity type {suffix} must include all Property types of {prefix} without any changes.'
            )
            missing = ', '.join(difference)
            if missing != '':
                errors.append('The missing properties are: ')
                errors.append(missing)
            else:
                errors.append('There are no missing properties')
            errors.append('The changed property attributes are: ')
            changed = '\n'.join(changes)
            errors.append(changed)

        # Recursively call the function with the prefix
        check_prefix_prefix(o, prefix_2, entity_type, errors)


def entity_checker(file_path, o):
    errors = []

    workbook = openpyxl.load_workbook(file_path)
    sheet = workbook.active
    entity_type = sheet['A1'].value
    entity_headers = [cell.value for cell in sheet[2]]
    term_index = entity_headers.index('Code') + 1
    entity_code = sheet.cell(row=3, column=term_index).value

    try:
        openbis_entity = search_entity(o, entity_type, entity_code)
    except ValueError:
        errors.append(
            f"Entity type '{entity_code}' is a new entity type (not present in the system) to be registered."
        )
        openbis_entity = ''

    if openbis_entity != '':
        errors.append(f"Entity type '{entity_code}' already exists.")
        same_code_errors = check_entity_same_code(file_path, o, openbis_entity)
        errors.append(same_code_errors)
    else:
        diff_code_errors = check_entity_diff_code(file_path, o)
        errors.append(diff_code_errors)

    prefix_errors = check_prefix_sufix(file_path, o)
    errors.append(prefix_errors)

    return '\n'.join(errors)
